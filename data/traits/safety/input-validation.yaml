name: input-validation
display_name: "Input Validation"
category: safety
description: "Comprehensive input sanitization and validation to prevent injection attacks"

coordination_patterns:
  - name: "input_sanitization_check"
    trigger: "when implementing user input handling or API endpoints"
    action: "ensure comprehensive input validation and sanitization"
    context_required: ["input_types", "validation_rules", "sanitization_methods"]

  - name: "injection_prevention_review"
    trigger: "before deploying features that process external data"
    action: "review code for injection vulnerabilities (SQL, XSS, LDAP, etc.)"
    context_required: ["attack_vectors", "prevention_methods", "testing_strategies"]

implementation: |
  ## Input Validation Security Protocol

  **CRITICAL: Validate and sanitize all external input**

  ### Input Validation Principles
  1. **Validate Early and Often**:
     - Validate at application boundaries (API, UI, file uploads)
     - Use whitelist validation (allow known good) over blacklist
     - Validate data type, length, format, and range
     - Reject invalid input with clear error messages

  2. **Context-Aware Sanitization**:
     - Sanitize based on usage context (HTML, SQL, shell, etc.)
     - Use appropriate encoding for output context
     - Apply principle of least privilege for data processing
     - Never trust user input, even from authenticated users

  3. **Common Injection Prevention**:
     - **SQL Injection**: Use parameterized queries/prepared statements
     - **XSS Prevention**: HTML encode output, use CSP headers
     - **Command Injection**: Avoid shell execution, use safe APIs
     - **LDAP Injection**: Escape LDAP special characters
     - **XML Injection**: Use XML parsers with entity processing disabled

  ### Validation Strategies
  - **Server-Side Validation**: Always validate on the server
  - **Client-Side Validation**: For user experience only, never security
  - **Schema Validation**: Use JSON Schema, OpenAPI specs
  - **Business Logic Validation**: Enforce business rules and constraints

  ### Secure Coding Patterns
  ```python
  # GOOD - Parameterized query
  cursor.execute("SELECT * FROM users WHERE id = %s", (user_id,))
  
  # BAD - String concatenation
  # cursor.execute(f"SELECT * FROM users WHERE id = {user_id}")
  ```

  ### Testing and Verification
  - Automated security testing in CI/CD
  - Regular penetration testing and code review
  - Input fuzzing and boundary testing
  - Security scanner integration

  ### Coordination Examples
  - "Input validation implemented - SQL injection prevented"
  - "XSS prevention controls verified for user-generated content"
  - "Command injection testing passed - shell execution secured"