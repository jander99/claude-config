# Template Caching and Optimization Strategy

**Stream B1: Trait Architecture Design**  
**Focus**: Template system optimization for 6,000+ line agents  
**Performance Target**: <2 seconds template rendering per agent  
**Version**: 1.0

## Executive Summary

This document outlines the template optimization strategy to handle the 12x-20x content expansion from ~500-line YAML sources to 6,000-11,000 line generated agents. The current monolithic template approach will be replaced with a modular, cached, and optimized system.

## Current Template System Analysis

### Current State
- **Single Template**: 538-line monolithic `agent.md.j2`
- **No Caching**: Templates recompiled on every render
- **Sequential Processing**: No parallelization or optimization
- **Memory Inefficient**: Loads entire content into memory
- **No Modularity**: All logic in single template file

### Performance Issues
- Template compilation: ~200-500ms per agent (repeated)
- Content rendering: ~2-5s per agent (unoptimized)
- Memory usage: High due to no content streaming
- No reuse: Duplicate compilation across similar agents

## Enhanced Template Architecture

### 1. Modular Template System

#### Template Hierarchy
```
templates/
├── base/
│   ├── agent-base.j2           # Core agent structure
│   ├── header.j2               # YAML frontmatter
│   └── footer.j2               # Generated by signature
├── sections/
│   ├── core-responsibilities.j2 # Responsibilities section
│   ├── expertise-areas.j2       # Expertise listing
│   ├── technology-stack.j2      # Technology frameworks
│   ├── implementation-patterns.j2 # Code patterns
│   ├── professional-standards.j2 # Standards and compliance
│   ├── integration-guidelines.j2 # Integration patterns
│   ├── performance-benchmarks.j2 # Performance criteria
│   ├── troubleshooting.j2       # Troubleshooting guides
│   └── tool-configurations.j2   # Tool setup configs
├── traits/
│   ├── coordination-traits.j2   # Coordination trait rendering
│   ├── tool-traits.j2          # Tool stack trait rendering
│   ├── safety-traits.j2        # Safety protocol rendering
│   └── enhancement-traits.j2    # Enhancement trait rendering
└── fragments/
    ├── code-block.j2           # Code formatting fragment
    ├── list-item.j2            # List formatting fragment
    ├── table.j2                # Table formatting fragment
    └── badge.j2                # Badge/status fragment
```

#### Template Composition Strategy
```python
class ModularTemplateEngine:
    def __init__(self):
        self.base_templates = self._load_base_templates()
        self.section_templates = self._load_section_templates()
        self.trait_templates = self._load_trait_templates()
        self.fragment_templates = self._load_fragment_templates()
    
    def render_agent(self, agent_config: AgentConfig) -> str:
        sections = []
        
        # Render each section independently
        for section_name in agent_config.enabled_sections:
            section_content = self._render_section(section_name, agent_config)
            sections.append(section_content)
        
        # Compose final agent from sections
        return self._compose_agent(sections, agent_config)
```

### 2. Template Compilation Caching

#### Compilation Cache Architecture
```python
class TemplateCompilationCache:
    def __init__(self):
        self.compiled_templates: Dict[str, CompiledTemplate] = {}
        self.template_metadata: Dict[str, TemplateMetadata] = {}
        self.dependency_graph: Dict[str, Set[str]] = {}
        self.cache_stats = CacheStatistics()
    
    def get_compiled_template(self, template_path: str) -> CompiledTemplate:
        if template_path not in self.compiled_templates:
            self._compile_template(template_path)
        return self.compiled_templates[template_path]
    
    def invalidate_template(self, template_path: str) -> None:
        # Invalidate template and dependents
        dependents = self._get_dependents(template_path)
        for dependent in dependents:
            self.compiled_templates.pop(dependent, None)
```

#### Template Precompilation Strategy
1. **Startup Compilation**: Compile all templates at application start
2. **Dependency Resolution**: Build template dependency graph
3. **Incremental Updates**: Recompile only changed templates and dependents
4. **Memory Optimization**: LRU eviction for rarely-used compiled templates

### 3. Content Rendering Optimization

#### Streaming Content Generation
```python
class StreamingRenderer:
    def __init__(self, chunk_size: int = 64 * 1024):
        self.chunk_size = chunk_size
        self.buffer_pool = BufferPool()
    
    def render_section_stream(self, template: CompiledTemplate, 
                            context: Dict) -> Iterator[str]:
        """Render template content in chunks for memory efficiency."""
        for chunk in template.render_chunked(context):
            yield chunk
    
    def assemble_agent_stream(self, section_streams: List[Iterator[str]]) -> str:
        """Assemble agent content from section streams."""
        result_buffer = self.buffer_pool.get_buffer()
        try:
            for section_stream in section_streams:
                for chunk in section_stream:
                    result_buffer.write(chunk)
            return result_buffer.getvalue()
        finally:
            self.buffer_pool.return_buffer(result_buffer)
```

#### Progressive Rendering
- **Early Sections**: Render header and core sections first
- **Parallel Processing**: Render independent sections concurrently  
- **Lazy Loading**: Load trait content only when template needs it
- **Memory Management**: Stream content to reduce peak memory usage

### 4. Template Fragment Optimization

#### Fragment Caching Strategy
```python
class FragmentCache:
    def __init__(self, max_size: int = 10000):
        self.cache: Dict[str, CachedFragment] = {}
        self.lru_tracker = LRUTracker(max_size)
    
    def get_fragment(self, fragment_key: str, context_hash: str) -> Optional[str]:
        cache_key = f"{fragment_key}:{context_hash}"
        return self.cache.get(cache_key)
    
    def put_fragment(self, fragment_key: str, context_hash: str, 
                    content: str) -> None:
        cache_key = f"{fragment_key}:{context_hash}"
        self.cache[cache_key] = CachedFragment(content, time.time())
        self.lru_tracker.access(cache_key)
```

#### Common Fragment Optimization
- **Code Blocks**: Cache formatted code examples
- **Lists**: Cache common list formatting patterns
- **Tables**: Cache formatted technology stacks
- **Badges**: Cache status and version badges

## Performance Optimization Strategies

### 1. Template Compilation Performance

#### Optimization Techniques
- **AST Caching**: Cache Jinja2 AST for reuse
- **Template Inheritance**: Use extends/include for common patterns
- **Macro Libraries**: Create reusable template macros
- **Conditional Compilation**: Compile only required template branches

#### Performance Targets
- Template compilation: <50ms per template (cold)
- Template rendering: <100ms per section
- Cache hit rate: >95% for compiled templates
- Memory usage: <100MB for all compiled templates

### 2. Content Generation Performance

#### Parallel Section Rendering
```python
class ParallelRenderer:
    def __init__(self, thread_pool_size: int = 4):
        self.executor = ThreadPoolExecutor(max_workers=thread_pool_size)
        self.section_dependencies = self._build_section_dependencies()
    
    def render_agent_parallel(self, agent_config: AgentConfig) -> str:
        # Create render tasks for independent sections
        futures = {}
        for section in self._get_independent_sections(agent_config):
            future = self.executor.submit(self._render_section, section, agent_config)
            futures[section] = future
        
        # Collect results and handle dependent sections
        results = {}
        for section, future in futures.items():
            results[section] = future.result()
        
        return self._assemble_results(results, agent_config)
```

#### Memory Optimization
- **Streaming Assembly**: Process content in chunks
- **Buffer Pooling**: Reuse allocated memory buffers
- **Garbage Collection**: Explicit cleanup of large objects
- **Memory Monitoring**: Track and limit memory usage

### 3. Cache Optimization

#### Multi-Level Caching Strategy
1. **Template Cache**: Compiled Jinja2 templates (L1)
2. **Fragment Cache**: Rendered template fragments (L2)  
3. **Content Cache**: Complete section content (L3)
4. **Result Cache**: Final agent content (L4)

#### Cache Invalidation
```python
class CacheInvalidationManager:
    def __init__(self):
        self.invalidation_graph = InvalidationGraph()
        self.version_tracker = VersionTracker()
    
    def invalidate_on_change(self, changed_file: str) -> None:
        # Determine what needs invalidation
        affected_items = self.invalidation_graph.get_affected(changed_file)
        
        # Invalidate caches in dependency order
        for item in affected_items:
            self._invalidate_cache_item(item)
    
    def _invalidate_cache_item(self, item: str) -> None:
        # Invalidate specific cache layers
        if item.startswith('template:'):
            self.template_cache.invalidate(item)
        elif item.startswith('fragment:'):
            self.fragment_cache.invalidate(item)
        elif item.startswith('content:'):
            self.content_cache.invalidate(item)
```

## Quality Gates and Validation

### 1. Template Quality Validation

#### Template Linting
- **Syntax Validation**: Jinja2 syntax checking
- **Semantic Validation**: Variable usage verification
- **Performance Validation**: Template complexity analysis
- **Security Validation**: Template injection prevention

#### Content Quality Checks
- **Size Validation**: 6,000-11,000 lines per agent
- **Structure Validation**: Required sections present
- **Format Validation**: Markdown syntax correctness
- **Link Validation**: Internal and external link checking

### 2. Performance Monitoring

#### Real-Time Metrics
```python
class TemplatePerformanceMonitor:
    def __init__(self):
        self.metrics = MetricsCollector()
        self.alerts = AlertManager()
    
    def track_render_time(self, template_name: str, duration: float) -> None:
        self.metrics.record('template_render_time', duration, 
                          tags={'template': template_name})
        
        if duration > self.get_threshold(template_name):
            self.alerts.send_alert(f"Template {template_name} slow: {duration}s")
    
    def track_cache_performance(self) -> None:
        hit_rate = self.cache.get_hit_rate()
        self.metrics.record('cache_hit_rate', hit_rate)
        
        if hit_rate < 0.95:
            self.alerts.send_alert(f"Cache hit rate low: {hit_rate:.2%}")
```

#### Performance Benchmarks
- **Template Compilation**: <50ms per template
- **Section Rendering**: <200ms per section
- **Total Agent Rendering**: <2s per agent
- **Memory Usage**: <500MB peak during rendering
- **Cache Hit Rate**: >95% for production workloads

## Implementation Roadmap

### Phase 1: Template Modularization (Week 1)
- Split monolithic template into sections
- Create base template hierarchy
- Implement basic template compilation cache
- Add performance monitoring framework

### Phase 2: Optimization Implementation (Week 2)
- Implement streaming content generation
- Add parallel section rendering
- Create fragment caching system
- Optimize memory usage patterns

### Phase 3: Integration and Validation (Week 3)
- Integrate with enhanced trait processor
- Add comprehensive quality validation
- Performance tuning and benchmarking
- Documentation and handoff preparation

## Success Criteria

1. **Performance**: <2 seconds template rendering per agent
2. **Scalability**: Support 6,000-11,000 line agents without degradation
3. **Memory Efficiency**: <500MB peak memory usage during rendering
4. **Cache Effectiveness**: >95% cache hit rate for production workloads
5. **Maintainability**: Modular template architecture with clear separation

## Risk Mitigation

- **Complexity Risk**: Phased implementation with validation at each step
- **Performance Risk**: Continuous benchmarking and optimization
- **Memory Risk**: Streaming architecture with explicit resource management
- **Quality Risk**: Comprehensive validation and monitoring framework

This template optimization strategy provides the foundation for efficiently generating 6,000+ line agents while maintaining performance and quality standards.